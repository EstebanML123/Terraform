version: '3.8'

services:
  test-mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: appdb
      MYSQL_USER: appuser
      MYSQL_PASSWORD: apppassword
    volumes:
      # ✅ Ruta absoluta segura (evita errores en Jenkins)
      - ${PWD}/db/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - test-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 15s

  test-redis:
    image: redis:7-alpine
    networks:
      - test-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 5s

  test-web:
    build:
      context: .
      dockerfile: app/Dockerfile
    container_name: test-web
    depends_on:
      test-mysql:
        condition: service_healthy
      test-redis:
        condition: service_healthy
    environment:
      MYSQL_HOST: test-mysql
      MYSQL_USER: appuser
      MYSQL_PASSWORD: apppassword
      MYSQL_DATABASE: appdb
      REDIS_HOST: test-redis
      FLASK_ENV: testing
      PYTHONUNBUFFERED: 1
    # ✅ Usa root solo en pruebas (evita errores de permisos)
    user: root
    command: >
      bash -c "
        mkdir -p /app/.pytest_cache &&
        chmod -R 777 /app/.pytest_cache &&
        echo '=== Ejecutando tests con pytest ===' &&
        python wait_for_db.py --host test-mysql --port 3306 --user appuser --password apppassword --database appdb --timeout 30 &&
        pytest --maxfail=1 --disable-warnings -v
      "
    volumes:
      - .:/app
    networks:
      - test-network

networks:
  test-network:
    driver: bridge
